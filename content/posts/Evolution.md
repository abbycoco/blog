+++
title = "web Evolution"
date = 2019-03-14T16:46:53+08:00
tags = ["web"]
categories = ["web"]
draft = false
description = 'web溯源'
+++
- 简单明快的早期时代

  初期的开发模式前后端并没有分离，页面由JSP、PHP工程师在服务器生成，浏览器负责展示界面。

  从逻辑上来说，本该分开的连在一起必然有特殊的优势：

  1、本地搭建一个 tomcat 就可以开发了，简单明快，使用 VBScript 、JScript 等简单易懂的脚本语言，结合HTML代码，即可快速地完成网站的应用程序。

  2、无须compile编译，容易编写，可在服务器端直接执行，首屏渲染速度快，白屏时间短。

  3、使用普通的文本编辑器，如Windows的记事本，即可进行编辑设计。

  4、与浏览器无关(BrowserIndependence),客户端只要使用可执行HTML码的浏览器，即可浏览 Actbive Server Pages 所设计的网页内容。Active ServerPages 所使用的脚本语言 (VBScript 、 Jscript) 均在 WEB 服务器端执行，客户端的浏览器不需要能够执行这些脚本语言。

  5、Active Server Pages能与任何ActiveX scripting语言兼容。除了可使用VBScript或JScript语言来设计外，还通过plug－in的方式，使用由第三方所提供的其它脚本语言，譬如REXX 、Perl 、Tcl等。脚本引擎是处理脚本程序的COM(Component Object Model) 对象。

  6、可使用服务器端的脚本来产生客户端的脚本。

  7、ActiveX Server Components(ActiveX 服务器组件 )具有无限可扩充性。可以使用Visual Basic 、Java 、Visual C＋＋ 、COBOL等程序设计语言来编写你所需要的ActiveX Server Component 。

  也有致命的硬伤：
  但是随着业务复杂程度的提高， server 变得越来越多，很多代码变得不那么清晰，就会出现很多灰色地带，有时候为了赶项目，为了完成紧急需求，就会早JSP里面糅杂大量的业务代码。积攒到一定阶段后，往往会带来高额的维护成本

- 后端为主的 MVC 时代

  为了降低复杂度，以后端为出发点，有了 Web Server 层的架构升级，比如 Structs、Spring MVC 等，成就了后端的 MVC 时代。

  代码可维护性得到明显好转，MVC 是个非常好的协作模式，从架构层面让开发者懂得什么代码应该写在什么地方。为了让 View 层更简单干脆，还可以选择 Velocity、Freemaker 等模板，使得模板里写不了 Java 代码。看起来是功能变弱了，但正是这种限制使得前后端分工更清晰。然而依旧并不是那么清晰，这个阶段的典型问题是：

  1、前端开发重度依赖开发环境。这种架构下，前后端协作有两种模式：一种是前端写 demo ，写好后，让后端去套模板。淘宝早期包括现在依旧有大量业务线是这种模式。好处很明显， demo 可以本地开发，很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大。另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发，支付宝是这种模式。好处是 UI 相关的代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开发效率的重要因素。

  2、前后端职责依旧纠缠不清。 Velocity 模板还是蛮强大的，变量、逻辑、宏等特性，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 Controller ，页面路由等功能本应该是前最关注的，但却是由后端来实现。 Controller 本身与 Model 往往也会纠缠不清，看了让人咬牙的代码经常会出现在 Controller  层。这些问题不能全归结于程序员的素养，否则 JSP 就够了。

- Ajax 带来的 SPA 时代

  2004 年 Gmail 像风一样的女子来到人间，很快2005年Ajax正式提出，加上CDN开始大量用于静态资源存储，于是出现了 JavaScript 王者归来的 SPA（SinglePageApplication单页面应用 ）时代。

  这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript ，浏览器端变得很复杂。

  对于 SPA 应用，有几个很重要的挑战：

  1、前后端接口的约定。如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很痛苦。这一块在业界有 API Blueprint 等方案来约定和沉淀接口，在阿里，不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的接口规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。相信这一块会越做越好。

  2、前端开发的复杂度控制。SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。典型的解决方案是业界的 Backbone，但 Backbone 做的事还很有限，依旧存在大量空白区域需要挑战。

  SPA 让前端看到了一丝绿色，但依旧是在荒漠中行走。

- 前端为主的 MVC 时代

  为了降低前端开发复杂度，除了 Backbone，还有大量框架涌现，比如 EmberJS、KnockoutJS、AngularJS 等等。

  好处很明显：

  1、前后端职责很清晰。前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful 等接口。

  2、前端开发的复杂度可控。前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代码应该如何组织，所有这一切设计，得花一本的厚度去说明。

  3、部署相对独立，产品体验可以快速改进。

  4、通过将开发团队前后端分离化，让前后端工程师只需要专注于前端或后端的开发工作，是的前后端工程师实现自治，培养其独特的技术特性，然后构建出一个全栈式的精益开发团队。

  5、前后端分离以后，可以实现前后端代码的解耦，只要前后端沟通约定好应用所需接口以及接口参数，便可以开始并行开发，无需等待对方的开发工作结束。与此同时，即使需求发生变更，只要接口与数据格式不变，后端开发人员就不需要修改代码，只要前端进行变动即可。如此一来整个应用的开发效率必然会有质的提升。

  6、如果开发团队能完成前后端分离的转型，打造优秀的前后端团队，开发独立化，让开发人员做到专注专精，开发能力必然会有所提升，能够完美应对各种复杂多变的前端需求。

  7、前后端分离后，应用的代码不再是前后端混合，只有在运行期才会有调用依赖关系。

  但依旧有不足之处：

  代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。
  全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。
  性能并非最佳，特别是移动互联网环境下。
  SPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌控。

- Node 带来的全栈时代

  前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 Node.js 的兴起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式

  在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职：

  1、Front-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功能，HTML 的生成也可以放在这层，具体看应用场景。

  2、Back-end UI layer 处理路由、模板、数据获取、cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱对展现的强关注，转而可以专心于业务逻辑层的开发。

  通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。

  与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。
